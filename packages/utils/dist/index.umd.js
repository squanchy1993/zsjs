(function(o,d){typeof exports=="object"&&typeof module<"u"?d(exports):typeof define=="function"&&define.amd?define(["exports"],d):(o=typeof globalThis<"u"?globalThis:o||self,d(o.index={}))})(this,function(o){"use strict";function d(s,t=1e3){let e=!1,i,r=1e3;t&&(r=t);const a=async()=>{try{await s()}finally{e&&(i=setTimeout(()=>{clearTimeout(i),a()},r))}};return{start:()=>{if(e)throw new Error("ready start!");e=!0,a()},stop:()=>e=!1,refresh:a,setTime:u=>{r=u}}}function y({cb:s,retryCount:t,intervalTime:e,event:i}){let r=!1,a=!1,n=()=>{};return{promise:new Promise(async(l,u)=>{n=()=>{if(r==!0)return;t=0,a=!0,r=!0;const c="Because of reason [user cancel], re-execute end";return console.warn(c),i(c),u(new Error(c))};const m=async()=>{try{const c=await s();r=!0,l(c)}catch(c){if(a)return;let g="";c instanceof Error?g=c.message:g=JSON.stringify(c);const w=`Because of reason [${g}], start re-execute on ${t}`;if(console.warn(w),i(w),t==0){const P=`Because of reason [${g}], re-execute end`;console.error(P),i(P),r=!0,u(c)}else t!==0&&(t>0&&t--,setTimeout(()=>{m()},e))}};m()}),cancel:n}}function E(s,t){let e=n=>{},i;t&&(i=setTimeout(()=>{e("execute function timeout")},t));const r=new Promise((n,h)=>{e=(l="promise aborted")=>{h(new b(l))}});return{promise:Promise.race([s,r]).then(n=>(i&&(clearTimeout(i),i=void 0),n)),abort:e}}class b extends Error{constructor(t){super(t)}}function f(s){return s&&(Array.isArray(s)?s.map(t=>f(t)):s instanceof Date?new Date(s):typeof s=="object"?Object.fromEntries(Object.entries(s).map(([t,e])=>[t,f(e)])):s)}function L(s){const t=f(s);return{data:s,defaultData:t,getClone:()=>f(t)}}class S{constructor(t){this.events={},t.forEach(e=>{Reflect.set(this.events,e,[])})}addEventListener(t,e){if(!Reflect.has(this.events,t))throw new Error(`event ${t} doesn't exist!`);this.events[t].includes(e)||this.events[t].push(e)}removeEventListener(t,e){if(!Reflect.has(this.events,t))throw new Error(`event ${t} doesn't exist!`);const i=this.events[t].indexOf(e);i!==-1&&this.events[t].splice(i,1)}dispatchEvent(t,e){if(!Reflect.has(this.events,t))throw new Error(`event ${t} doesn't exist!`);this.events[t].forEach(i=>i(e))}}function p(s={},t={}){let e;for(e in t)s[e]=x(s[e])?p(s[e],t[e]):s[e]=t[e];return s}function x(s){return Object.prototype.toString.call(s)==="[object Object]"}const T={searchParams:{},pageParams:{pageIndex:1,pageSize:10},pageSizes:[10,30,50],list:[],total:0,totalPage:0,getListStatus:"succeed",searchStatus:"succeed",pagingStatus:"succeed"};class v{constructor({requestFun:t,listState:e}){this.events=new S(["changeState"]),this.setListState=i=>{let r={set:(n,h,l)=>{Reflect.set(n,h,l);const u=f(n);return this.events.dispatchEvent("changeState",u),!0}};const a=p(T,i);return new Proxy(a,r)},this.getList=()=>new Promise((i,r)=>{this.listState.getListStatus==="loading"&&r(new Error("加载中,请稍等")),this.listState.getListStatus="loading";const a={...this.listState.searchParams,page:this.listState.pageParams};this.requestFun(a).then(n=>{const{list:h,total:l,totalPage:u=0}=n;this.listState.totalPage=u,this.listState.total=l,this.listState.list=h,this.listState.getListStatus="succeed",i(n)}).catch(n=>{console.error(n),this.listState.getListStatus="failed",r(n)})}),this.handleSearch=async()=>{this.listState.searchStatus="loading",this.listState.pageParams.pageIndex=1;try{const i=await this.getList();return this.listState.searchStatus="succeed",i}catch(i){console.error("search get error:"+i),this.listState.searchStatus="failed"}},this.handlePageChange=async({pageIndex:i,pageSize:r})=>{this.listState.pagingStatus="loading",i&&(this.listState.pageParams.pageIndex=i),r&&(this.listState.pageParams.pageSize=r);try{const a=await this.getList();return this.listState.pagingStatus="succeed",a}catch(a){console.error("search get error:"+a),this.listState.pagingStatus="failed"}},this.listState=this.setListState(e),t&&(this.requestFun=t)}}o.EventsCollect=S,o.ListInstance=v,o.cancelablePromise=E,o.dataWithDefault=L,o.deepClone=f,o.loopFunc=d,o.reExecute=y,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
