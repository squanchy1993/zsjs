(function(s,f){typeof exports=="object"&&typeof module<"u"?f(exports):typeof define=="function"&&define.amd?define(["exports"],f):(s=typeof globalThis<"u"?globalThis:s||self,f(s.index={}))})(this,function(s){"use strict";function f(t,e=1e3){let r=!1,n,o=1e3;e&&(o=e);const c=async()=>{try{await t()}finally{r&&(n=setTimeout(()=>{clearTimeout(n),c()},o))}};return{start:()=>{if(r)throw new Error("ready start!");r=!0,c()},stop:()=>r=!1,refresh:c,setTime:m=>{o=m}}}function w({cb:t,retryCount:e,intervalTime:r,event:n}){let o=!1,c=!1,a=()=>{};return{promise:new Promise(async(l,m)=>{a=()=>{if(o==!0)return;e=0,c=!0,o=!0;const i="Because of reason [user cancel], re-execute end";return console.warn(i),n(i),m(new Error(i))};const y=async()=>{try{const i=await t();o=!0,l(i)}catch(i){if(c)return;let d="";i instanceof Error?d=i.message:d=JSON.stringify(i);const b=`Because of reason [${d}], start re-execute on ${e}`;if(console.warn(b),n(b),e==0){const g=`Because of reason [${d}], re-execute end`;console.error(g),n(g),o=!0,m(i)}else e!==0&&(e>0&&e--,setTimeout(()=>{y()},r))}};y()}),cancel:a}}function T(t,e){let r=a=>{},n;e&&(n=setTimeout(()=>{r("execute function timeout")},e));const o=new Promise((a,p)=>{r=(l="promise aborted")=>{p(new h(l))}});return{promise:Promise.race([t,o]).then(a=>(n&&(clearTimeout(n),n=void 0),a)),abort:r}}class h extends Error{constructor(e){super(e)}}function u(t){return t&&(Array.isArray(t)?t.map(e=>u(e)):t instanceof Date?new Date(t):typeof t=="object"?Object.fromEntries(Object.entries(t).map(([e,r])=>[e,u(r)])):t)}function E(t){const e=u(t);return{data:t,defaultData:e,getClone:()=>u(e)}}s.cancelablePromise=T,s.dataWithDefault=E,s.deepClone=u,s.loopFunc=f,s.reExecute=w,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
