(function(n,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(n=typeof globalThis<"u"?globalThis:n||self,a(n.index={}))})(this,function(n){"use strict";function a(s,e=1e3){let t=!1,r,o=1e3;e&&(o=e);const c=async()=>{try{await s()}finally{t&&(r=setTimeout(()=>{clearTimeout(r),c()},o))}};return{start:()=>{if(t)throw new Error("ready start!");t=!0,c()},stop:()=>t=!1,refresh:c,setTime:d=>{o=d}}}function y({cb:s,retryCount:e,intervalTime:t,event:r}){let o=!1,c=!1,f=()=>{};return{promise:new Promise(async(u,d)=>{f=()=>{if(o==!0)return;e=0,c=!0,o=!0;const i="Because of reason [user cancel], re-execute end";return console.warn(i),r(i),d(new Error(i))};const p=async()=>{try{const i=await s();o=!0,u(i)}catch(i){if(c)return;let h="";i instanceof Error?h=i.message:h=JSON.stringify(i);const E=`Because of reason [${h}], start re-execute on ${e}`;if(console.warn(E),r(E),e==0){const w=`Because of reason [${h}], re-execute end`;console.error(w),r(w),o=!0,d(i)}else e!==0&&(e>0&&e--,setTimeout(()=>{p()},t))}};p()}),cancel:f}}function b(s,e){let t=f=>{},r;e&&(r=setTimeout(()=>{t("execute function timeout")},e));const o=new Promise((f,m)=>{t=(u="promise aborted")=>{m(new g(u))}});return{promise:Promise.race([s,o]).then(f=>(r&&(clearTimeout(r),r=void 0),f)),abort:t}}class g extends Error{constructor(e){super(e)}}function l(s){return s&&(Array.isArray(s)?s.map(e=>l(e)):s instanceof Date?new Date(s):typeof s=="object"?Object.fromEntries(Object.entries(s).map(([e,t])=>[e,l(t)])):s)}function T(s){const e=l(s);return{data:s,defaultData:e,getClone:()=>l(e)}}class x{constructor(e){this.events={},e.forEach(t=>{Reflect.set(this.events,t,[])})}addEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].includes(t)||this.events[e].push(t)}removeEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);const r=this.events[e].indexOf(t);r!==-1&&this.events[e].splice(r,1)}dispatchEvent(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].forEach(r=>r(t))}}n.EventsCollect=x,n.cancelablePromise=b,n.dataWithDefault=T,n.deepClone=l,n.loopFunc=a,n.reExecute=y,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})});
