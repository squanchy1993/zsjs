(function(u,g){typeof exports=="object"&&typeof module<"u"?g(exports):typeof define=="function"&&define.amd?define(["exports"],g):(u=typeof globalThis<"u"?globalThis:u||self,g(u.index={}))})(this,function(u){"use strict";const g=c=>{if(typeof c=="object"&&c!==null){if(typeof Object.getPrototypeOf=="function"){const e=Object.getPrototypeOf(c);return e===Object.prototype||e===null}return Object.prototype.toString.call(c)==="[object Object]"}return!1},l=(...c)=>c.reduce((e,t)=>{if(Array.isArray(t))throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");return Object.keys(t).forEach(s=>{["__proto__","constructor","prototype"].includes(s)||(Array.isArray(e[s])&&Array.isArray(t[s])?e[s]=l.options.mergeArrays?l.options.uniqueArrayItems?Array.from(new Set(e[s].concat(t[s]))):[...e[s],...t[s]]:t[s]:g(e[s])&&g(t[s])?e[s]=l(e[s],t[s]):e[s]=t[s]===void 0?l.options.allowUndefinedOverrides?t[s]:e[s]:t[s])}),e},{}),f={allowUndefinedOverrides:!0,mergeArrays:!0,uniqueArrayItems:!0};l.options=f,l.withOptions=(c,...e)=>{l.options=Object.assign(Object.assign({},f),c);const t=l(...e);return l.options=f,t};class S extends Promise{constructor(e,t){let s,n;super((i,r)=>{e(i,r),s=i,n=r}),this.resolve=s,this.reject=n,this.cancelPromise=t}cancel(){var e,t;(e=this.reject)==null||e.call(this,"promise has been canceled"),(t=this.cancelPromise)==null||t.call(this)}}var o=(c=>(c.closed="closed",c.connecting="connecting",c.connected="connected",c.closing="closing",c))(o||{});class C{constructor(e){this.events={},e.forEach(t=>{Reflect.set(this.events,t,[])})}addEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].includes(t)||this.events[e].push(t)}removeEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);const s=this.events[e].indexOf(t);s!==-1&&this.events[e].splice(s,1)}dispatchEvent(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].forEach(s=>s(t))}}function v({cb:c,retryCount:e,intervalTime:t,event:s}){let n=!1,i=()=>{};return{promise:new Promise(async(m,d)=>{i=()=>{e=0,n=!0;const h="Because of reason [user cancel], re-execute end";return console.warn(h),s(h),d(new Error(h))};const T=async()=>{try{const h=await c();m(h)}catch(h){if(n)return;let p=`${h}`;h instanceof Error&&(p=h.message);const b=`Because of reason [${p}], start re-execute on ${e}`;if(console.warn(b),s(b),e==0){const w=`Because of reason [${p}], re-execute end`;console.error(w),s(w),d(h)}else e!==0&&(e>0&&e--,setTimeout(()=>{T()},t))}};T()}),cancel:i}}class E{constructor({wsController:e,options:t}){this.sendTimer=null,this.reSendTimer=null,this.connectingXPromise=null,this.startTime=0,this.options={handleHeartbeatMsg:s=>!0,timeout:5e3,intervalTime:5e3,sendMsg:"---- heartbeat ----"},this.wsController=e,this.setOptions(t)}setOptions(e={}){this.options=l(this.options,e)}send(){const e=`heartbeat send message: ${this.options.sendMsg}`;this.wsController.events.dispatchEvent("log",e),this.startTime=new Date().getTime(),this.wsController.send(this.options.sendMsg),this.sendTimer&&clearTimeout(this.sendTimer),this.sendTimer=setTimeout(async()=>{this.wsController.connectStatus==o.connected&&await this.wsController._wsClose(),this.connectingXPromise=v({cb:()=>this.wsController._wsConnect({}),retryCount:-1,intervalTime:2e3,event:t=>this.wsController.events.dispatchEvent("log",t)})},this.options.timeout)}received(e){var i,r;if(!this.sendTimer||!((r=(i=this.options).handleHeartbeatMsg)==null?void 0:r.call(i,e)))return;let s=new Date().getTime();const n=`heartbeat started at ${this.startTime}, completed in ${s}', duration is ${(s-this.startTime)/1e3} seconds`;this.wsController.events.dispatchEvent("log",n),this.startTime=0,this.sendTimer&&(clearTimeout(this.sendTimer),this.sendTimer=null),this.reSendTimer||(this.reSendTimer=setTimeout(()=>{this.send(),this.reSendTimer&&clearTimeout(this.reSendTimer),this.reSendTimer=null},this.options.intervalTime))}clear(){this.sendTimer&&clearTimeout(this.sendTimer),this.sendTimer=null,this.reSendTimer&&clearTimeout(this.reSendTimer),this.reSendTimer=null,this.connectingXPromise&&this.connectingXPromise.cancel(),this.wsController.events.dispatchEvent("log","heartbeat was cleared out by user")}}let a=null;class O{constructor(e){this.options={address:"",connectTimeout:5e3,reconnectIntervalTime:2e3,retry:2,onOpened:function(){}},this._connectStatus=o.closed,this.connectingCb={resovle:null,reject:null},this.closingCb={resovle:null,reject:null},this.pause=!1,this.connectingTimer=null,this.closingTimer=null,this.heartbeat=new E({wsController:this}),this.events=new C(["message","log","status"]),this.setOptions(e)}get connectStatus(){return this._connectStatus}set connectStatus(e){this._connectStatus=e,this.events.dispatchEvent("status",this._connectStatus)}setOptions({wsOptions:e,heartbeatOptions:t}){this.options=l(this.options,e??{}),this.heartbeat.setOptions(t)}_setSocketInstance(e){const t=this;a=new WebSocket(e),a.onopen=function(s){var n,i,r,m;if(t.connectStatus==o.connecting){t.connectStatus=o.connected;const d="Websocket start success.";(i=(n=t.connectingCb)==null?void 0:n.resovle)==null||i.call(n,{success:!0,message:d}),t.events.dispatchEvent("log",d),t._clearConnect(),(m=(r=t.options).onOpened)==null||m.call(r,t),setTimeout(()=>{t.heartbeat.send()},1e3)}},a.onclose=function(s){var n,i;if(t.connectStatus==o.closing){t.connectStatus=o.closed;const r="Websocket closed success";(i=(n=t.closingCb)==null?void 0:n.resovle)==null||i.call(n,{success:!0,message:r}),t.events.dispatchEvent("log",r),t._clearClose()}},a.onerror=function(s){var n,i,r,m;if(t.connectStatus==o.connecting){t.connectStatus=o.closed;const d="Websocket start error";(i=(n=t.connectingCb)==null?void 0:n.reject)==null||i.call(n,{success:!1,message:d}),t.events.dispatchEvent("log",d),t._clearConnect()}else t.connectStatus==o.closing&&(t.connectStatus=o.connecting,(m=(r=t.closingCb)==null?void 0:r.reject)==null||m.call(r,{success:!1,message:`关闭失败: onerror:${s}`}),t._clearClose())},a.onmessage=function(s){t.heartbeat.received(s),!t.pause&&t.events.dispatchEvent("message",s)}}async _wsConnect(e){return new Promise((t,s)=>{try{let n=l(this.options,e??{});if(this.connectStatus==o.connected){const i="Websocket already connected";return this.events.dispatchEvent("log",i),t({success:!0,message:i})}if(this.connectStatus!==o.closed){const i=`Websocket connect failed: connectStatus current is ${this.connectStatus} not closed`;throw new Error(i)}this.connectingCb.resovle=t,this.connectingCb.reject=s,this.connectStatus=o.connecting,this._setSocketInstance(n.address),this.connectingTimer=setTimeout(()=>{throw new Error("Websocket connect timeout")},n.connectTimeout)}catch(n){this.connectStatus=o.closed,a==null||a.close();let i=`${n}`;n instanceof Error&&(i=n.message);const r=`connect failed: ${i}`;this.events.dispatchEvent("log",r),this._clearConnect(),s({success:!1,message:r})}})}_clearConnect(){this.connectingCb.resovle=null,this.connectingCb.reject=null,this.connectingTimer&&(clearTimeout(this.connectingTimer),this.connectingTimer=null)}async _wsClose(){return new Promise((e,t)=>{if(this.connectStatus==o.closed){const s="Websocket already closed";return this.events.dispatchEvent("log",s),e({success:!0,message:s})}if(this.connectStatus!==o.connected){const s=`Websocket close filed: connectStatus current is ${this.connectStatus} not in connected.`;return this.events.dispatchEvent("log",s),t({success:!1,message:s})}this.closingCb.resovle=e,this.closingCb.reject=t,this.connectStatus=o.closing,a==null||a.close(),this.closingTimer=setTimeout(()=>{this.connectStatus=o.closed;const s="Websocket close were timeout so it forced shutdown";this.events.dispatchEvent("log",s),e({success:!0,message:s}),this._clearClose()},2e3)})}_clearClose(){this.closingCb.resovle=null,this.closingCb.reject=null,this.closingTimer&&(clearTimeout(this.closingTimer),this.closingTimer=null)}connect(e){return this.connectingXPromise=v({cb:()=>this._wsConnect(e),retryCount:3,intervalTime:0,event:t=>this.events.dispatchEvent("log",t)}),this.connectingXPromise.promise}async close(){var e;(e=this.connectingXPromise)==null||e.cancel(),this.heartbeat.clear(),await this._wsClose()}send(e){if(this.connectStatus!==o.connected){const t="Websocket send error: connectStatus not in connected status.";throw this.events.dispatchEvent("log",t),new Error(t)}a==null||a.send(e)}addEventListener(e,t){this.events.addEventListener(e,t)}removeEventListener(e,t){this.events.removeEventListener(e,t)}}u.SocketStatus=o,u.WsController=O,u.XPromise=S,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
