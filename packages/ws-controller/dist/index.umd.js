(function(g,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(g=typeof globalThis<"u"?globalThis:g||self,p(g.index={}))})(this,function(g){"use strict";const p=o=>{if(typeof o=="object"&&o!==null){if(typeof Object.getPrototypeOf=="function"){const e=Object.getPrototypeOf(o);return e===Object.prototype||e===null}return Object.prototype.toString.call(o)==="[object Object]"}return!1},d=(...o)=>o.reduce((e,t)=>{if(Array.isArray(t))throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");return Object.keys(t).forEach(s=>{["__proto__","constructor","prototype"].includes(s)||(Array.isArray(e[s])&&Array.isArray(t[s])?e[s]=d.options.mergeArrays?d.options.uniqueArrayItems?Array.from(new Set(e[s].concat(t[s]))):[...e[s],...t[s]]:t[s]:p(e[s])&&p(t[s])?e[s]=d(e[s],t[s]):e[s]=t[s]===void 0?d.options.allowUndefinedOverrides?t[s]:e[s]:t[s])}),e},{}),b={allowUndefinedOverrides:!0,mergeArrays:!0,uniqueArrayItems:!0};d.options=b,d.withOptions=(o,...e)=>{d.options=Object.assign(Object.assign({},b),o);const t=d(...e);return d.options=b,t};class S extends Promise{constructor(e,t){let s,n;super((c,r)=>{e(c,r),s=c,n=r}),this.resolve=s,this.reject=n,this.cancelPromise=t}cancel(){var e,t;(e=this.reject)==null||e.call(this,"promise has been canceled"),(t=this.cancelPromise)==null||t.call(this)}}var h=(o=>(o.closed="closed",o.connecting="connecting",o.connected="connected",o.closing="closing",o))(h||{});class C{constructor(e){this.events={},e.forEach(t=>{Reflect.set(this.events,t,[])})}addEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].includes(t)||this.events[e].push(t)}removeEventListener(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);const s=this.events[e].indexOf(t);s!==-1&&this.events[e].splice(s,1)}dispatchEvent(e,t){if(!Reflect.has(this.events,e))throw new Error(`event ${e} doesn't exist!`);this.events[e].forEach(s=>s(t))}}function w({cb:o,retryCount:e,intervalTime:t,event:s}){let n=!1,c=!1,r=()=>{};return{promise:new Promise(async(u,i)=>{r=()=>{if(n==!0)return;e=0,c=!0,n=!0;const l="Because of reason [user cancel], re-execute end";return console.warn(l),s(l),i(new Error(l))};const a=async()=>{try{const l=await o();n=!0,u(l)}catch(l){if(c)return;let v="";l instanceof Error?v=l.message:v=JSON.stringify(l);const T=`Because of reason [${v}], start re-execute on ${e}`;if(console.warn(T),s(T),e==0){const E=`Because of reason [${v}], re-execute end`;console.error(E),s(E),n=!0,i(l)}else e!==0&&(e>0&&e--,setTimeout(()=>{a()},t))}};a()}),cancel:r}}function O(o,e){let t=r=>{},s;e&&(s=setTimeout(()=>{t("execute function timeout")},e));const n=new Promise((r,f)=>{t=(u="promise aborted")=>{f(new P(u))}});return{promise:Promise.race([o,n]).then(r=>(s&&(clearTimeout(s),s=void 0),r)),abort:t}}class P extends Error{constructor(e){super(e)}}class y{constructor({wsController:e,options:t}){this.connectingXPromise=null,this.startTime=0,this.options={handleHeartbeatMsg:s=>!0,timeout:5e3,intervalTime:5e3,sendMsg:"---- heartbeat ----"},this.wsController=e,this.setOptions(t)}setOptions(e={}){this.options=d(this.options,e)}send(){const e=`heartbeat send message: ${this.options.sendMsg}`;this.wsController.events.dispatchEvent("log",e),this.startTime=new Date().getTime(),this.sendTimer&&clearTimeout(this.sendTimer),this.sendTimer=setTimeout(async()=>{this.wsController.connectStatus==h.connected&&await this.wsController.close(),this.connectingXPromise=w({cb:()=>this.wsController.connect({},0,0),retryCount:-1,intervalTime:2e3,event:t=>this.wsController.events.dispatchEvent("log",t)})},this.options.timeout),this.wsController.send(this.options.sendMsg)}received(e){var c,r;if(!this.sendTimer||!((r=(c=this.options).handleHeartbeatMsg)==null?void 0:r.call(c,e)))return;let s=new Date().getTime();const n=`heartbeat started at ${this.startTime}, completed in ${s}', duration is ${(s-this.startTime)/1e3} seconds`;this.wsController.events.dispatchEvent("log",n),this.startTime=0,this.sendTimer&&(clearTimeout(this.sendTimer),this.sendTimer=void 0),this.reSendTimer||(this.reSendTimer=setTimeout(()=>{this.send(),this.reSendTimer&&clearTimeout(this.reSendTimer),this.reSendTimer=void 0},this.options.intervalTime))}clear(){this.sendTimer&&clearTimeout(this.sendTimer),this.sendTimer=void 0,this.reSendTimer&&clearTimeout(this.reSendTimer),this.reSendTimer=void 0,this.connectingXPromise&&this.connectingXPromise.cancel(),this.wsController.events.dispatchEvent("log","heartbeat was cleared out by user")}}let m=null;class W{constructor(e){this.options={address:"",connectTimeout:5e3,reconnectIntervalTime:2e3,retry:2,onOpened:function(){}},this._connectStatus=h.closed,this.closingCb={resovle:null,reject:null},this.pause=!1,this.connectingTimer=null,this.heartbeat=new y({wsController:this}),this.events=new C(["message","log","status"]),this.setOptions(e)}get connectStatus(){return this._connectStatus}set connectStatus(e){this._connectStatus=e,this.events.dispatchEvent("status",this._connectStatus)}setOptions({wsOptions:e,heartbeatOptions:t}){this.options=d(this.options,e??{}),this.heartbeat.setOptions(t)}_startWsConnect(e,t=0,s=0){const n=this;console.log("_startWsConnect>>>",e);const c=()=>new Promise((r,f)=>{m=new WebSocket(e),m.onopen=function(u){if(console.log("onopen",n.connectStatus),n.connectStatus==h.connecting){const i="Websocket start success.";n.events.dispatchEvent("log",i),r({success:!0,message:i})}},m.onmessage=function(u){console.log("onmessage",n.connectStatus),n.heartbeat.received(u),!n.pause&&n.events.dispatchEvent("message",u)},m.onerror=function(u){var i,a;if(console.log("Websocket onerror:",n.connectStatus),n.connectStatus==h.connecting){const l=`Websocket onerror:${u}`;f(new Error(l)),console.log("Websocket onerror: connecting",n.connectStatus,f),n.events.dispatchEvent("log",l)}else n.connectStatus==h.closing&&((a=(i=n.closingCb)==null?void 0:i.reject)==null||a.call(i,new Error(`Websocket onerror:${u}`)))},m.onclose=function(u){var i,a;if(console.log("onclose",n.connectStatus),n.connectStatus==h.closing){const l="Websocket closed success";(a=(i=n.closingCb)==null?void 0:i.resovle)==null||a.call(i,{success:!0,message:l}),n.events.dispatchEvent("log",l)}}});return w({cb:()=>O(c(),n.options.connectTimeout).promise,retryCount:t,intervalTime:s,event:r=>this.events.dispatchEvent("log",r)})}async connect(e,t=3,s=0){return new Promise(async(n,c)=>{var r,f,u;try{if(this.setOptions({wsOptions:e}),this.connectStatus==h.connected){const a="Websocket already connected";return this.events.dispatchEvent("log",a),n({success:!0,message:a})}if(!this.options.address){const a="Websocket adress not exsit";throw this.events.dispatchEvent("log",a),new Error(a)}if(this.connectStatus!==h.closed){const a=`Websocket connect failed: connectStatus current is ${this.connectStatus} not closed`;throw new Error(a)}this.connectStatus=h.connecting,(r=this.socketConnect)==null||r.cancel(),this.socketConnect=void 0,this.socketConnect=this._startWsConnect(this.options.address,t,s);let i=await this.socketConnect.promise;this.connectStatus=h.connected,(u=(f=this.options).onOpened)==null||u.call(f,this),setTimeout(()=>{this.heartbeat.send()},1e3),n(i),console.log("connect>>>: success",this.connectStatus)}catch(i){this.connectStatus=h.closed,console.log("connect>>>: error",i);let a=`${i}`;i instanceof Error&&(a=i.message);const l=`connect failed: ${a}`;this.events.dispatchEvent("log",l),c(new Error(l))}})}async _wsClose(){return new Promise((e,t)=>{clearTimeout(this.closingTimer),this.closingTimer=setTimeout(()=>{e({success:!0,message:"Websocket close were timeout so it forced shutdown"}),s()},2e3);const s=()=>{this.closingCb.resovle=null,this.closingCb.reject=null,clearTimeout(this.closingTimer)};this.closingCb.resovle=()=>{e({success:!0,message:"Websocket closed"}),s()},this.closingCb.reject=n=>{const c=`Websocket closed error: ${JSON.stringify(n.message)}`;e({success:!0,message:c}),s()},m==null||m.close()})}async close(){return new Promise(async(e,t)=>{var n;if(this.connectStatus==h.closed){const c="Websocket already closed";return this.events.dispatchEvent("log",c),e({success:!0,message:c})}if(this.connectStatus!==h.connected){const c=`Websocket close filed: connectStatus current is ${this.connectStatus} not in connected.`;return this.events.dispatchEvent("log",c),t(new Error(c))}this.connectStatus=h.closing;const{message:s}=await this._wsClose();this.events.dispatchEvent("log",s),this.connectStatus=h.closed,(n=this.socketConnect)==null||n.cancel(),this.heartbeat.clear(),e({success:!0,message:s})})}send(e){if(this.connectStatus!==h.connected){const t="Websocket send error: connectStatus not in connected status.";throw this.events.dispatchEvent("log",t),new Error(t)}m==null||m.send(e)}addEventListener(e,t){this.events.addEventListener(e,t)}removeEventListener(e,t){this.events.removeEventListener(e,t)}}g.SocketStatus=h,g.WsController=W,g.XPromise=S,Object.defineProperty(g,Symbol.toStringTag,{value:"Module"})});
